/**
 * @file ImuSensor.h
 * @brief Abstract interface for IMU sensors
 * 
 * This header defines the base interface for all IMU sensor implementations,
 * providing a unified API for accessing sensor data, calibration, and orientation.
 * 
 * @author Ivan Rybnikov
 * @copyright Copyright (c) 2024
 * @version 1.0
 */

#ifndef SENSOR_IMU_H
#define SENSOR_IMU_H

#include <Arduino.h>
#include <Wire.h>

#include "sh2.h"
#include "sh2_SensorValue.h"
#include "sh2_err.h"

/**
 * @struct IMUData
 * @brief Structure containing raw and processed IMU sensor data
 * 
 * This structure holds all the essential data from an IMU sensor including
 * acceleration, angular velocity, magnetic field, and quaternion orientation.
 * All data is provided in calibrated units for direct use in applications.
 */
struct IMUData {
    // Accelerometer data (m/s²)
    float ax, ay, az;                    // Calibrated acceleration data
    
    // Gyroscope data (rad/s)  
    float gx, gy, gz;                    // Calibrated angular velocity data
    
    // Magnetometer data (µT)
    float mx, my, mz;                    // Calibrated magnetic field data
    
    // Raw magnetometer data (LSB)
    int16_t mag_x, mag_y, mag_z;         // Raw magnetic field data for compatibility
    
    // Quaternion orientation (w, x, y, z)
    float q0, q1, q2, q3;                // DMP Quaternion if available from sensor
    
    // Data timestamp
    uint32_t timestamp;                  // Timestamp in milliseconds
};

/**
 * @struct OrientationData
 * @brief Structure containing orientation quaternion data
 * 
 * This structure holds the processed orientation data in quaternion format,
 * typically generated by sensor fusion algorithms like Madgwick or Mahony.
 */
struct OrientationData {
    // Quaternion components (w, x, y, z)
    float q0, q1, q2, q3;                // Orientation quaternion
    
    // Data timestamp
    uint32_t timestamp;                  // Timestamp in milliseconds
};

/**
 * @class ImuSensor
 * @brief Abstract base class for IMU sensor implementations
 * 
 * This class defines the interface that all IMU sensor implementations must follow.
 * It provides methods for data acquisition, calibration, orientation tracking,
 * and callback-based event handling.
 * 
 * @note This is an abstract class and cannot be instantiated directly.
 *       Use concrete implementations like ImuBNO08X or IMUSensor_BNO055.
 */
class ImuSensor {
protected:
    // Logging stream for debug output
    Stream* logStream;
    
    // Sensor frequency settings
    uint16_t orientationFrequency;        // Orientation update frequency (Hz)
    uint16_t imuFrequency;               // IMU data update frequency (Hz)

    // Event callback functions
    void (*orientationCb)(const OrientationData&);    // Orientation data callback
    void (*imuDataCb)(const IMUData&);                // IMU data callback

public:
    /**
     * @brief Constructor for ImuSensor
     * @param stream Pointer to Stream object for logging (default: Serial)
     */
    ImuSensor(Stream* stream = &Serial) : 
        logStream(stream), 
        orientationFrequency(0), 
        imuFrequency(0),
        orientationCb(nullptr),
        imuDataCb(nullptr)
    {}
    
    // ============================================================================
    // PURE VIRTUAL METHODS - Must be implemented by derived classes
    // ============================================================================
    
    /**
     * @brief Get current orientation data
     * @param orientation Reference to OrientationData structure to fill
     * @return true if data was successfully retrieved, false otherwise
     */
    virtual bool getOrientation(OrientationData& orientation) = 0;
    
    /**
     * @brief Get current IMU sensor data
     * @param data Reference to IMUData structure to fill
     * @return true if data was successfully retrieved, false otherwise
     */
    virtual bool getData(IMUData& data) = 0;
    
    /**
     * @brief Check if new orientation data is available
     * @return true if new orientation data is ready, false otherwise
     */
    virtual bool orientationDataReady() = 0;
    
    /**
     * @brief Check if new IMU data is available
     * @return true if new IMU data is ready, false otherwise
     */
    virtual bool imuDataReady() = 0;

    /**
     * @brief Start sensor calibration process
     * @return Calibration status code (0 = not calibrated, higher values = better calibration)
     */
    virtual uint16_t calibrate() = 0;
    
    /**
     * @brief Get calibration data from sensor
     * @param data Pointer to buffer to store calibration data
     */
    virtual void getCalibrationData(void* data) = 0;
    
    /**
     * @brief Set calibration data to sensor
     * @param data Pointer to calibration data buffer
     */
    virtual void setCalibrationData(void* data) = 0;

    // ============================================================================
    // VIRTUAL METHODS - Can be overridden by derived classes
    // ============================================================================
    
    /**
     * @brief Get current calibration status
     * @return Calibration status (0 = not calibrated, higher values = better calibration)
     */
    virtual uint16_t getCalibrationStatus() { return 0; }
    
    /**
     * @brief Get size of calibration data in bytes
     * @return Size of calibration data buffer in bytes
     */
    virtual uint16_t calibrationDataSize() { return 0; }

    /**
     * @brief Set orientation update frequency
     * @param frequency Desired frequency in Hz
     * @param emulate If true, emulate the frequency using software timing
     * @return true if frequency was set successfully, false otherwise
     */
    virtual bool setOrientationFrequency(uint16_t frequency, bool emulate = false) { 
        orientationFrequency = frequency; 
        return false;
    }
    
    /**
     * @brief Set IMU data update frequency
     * @param frequency Desired frequency in Hz
     * @param emulate If true, emulate the frequency using software timing
     * @return true if frequency was set successfully, false otherwise
     */
    virtual bool setIMUFrequency(uint16_t frequency, bool emulate = false) { 
        imuFrequency = frequency; 
        return false;
    }

    /**
     * @brief Start sensor services (if applicable)
     * This method can be used to start background services or interrupt handlers
     */
    virtual void startServices() {}
    
    /**
     * @brief Stop sensor services (if applicable)
     * This method can be used to stop background services or interrupt handlers
     */
    virtual void stopServices() {}

    // ============================================================================
    // PUBLIC METHODS - Available to all derived classes
    // ============================================================================
    
    /**
     * @brief Set logging stream for debug output
     * @param stream Pointer to Stream object for logging
     */
    void setLogStream(Stream* stream = &Serial) { logStream = stream; }

    /**
     * @brief Set callback function for orientation data
     * @param cb Function pointer to orientation data callback
     */
    void onOrientation(void (*cb)(const OrientationData&)) { orientationCb = cb; }
    
    /**
     * @brief Set callback function for IMU data
     * @param cb Function pointer to IMU data callback
     */
    void onIMUData(void (*cb)(const IMUData&)) { imuDataCb = cb; }

    /**
     * @brief Virtual destructor
     * Ensures proper cleanup of derived class objects
     */
    virtual ~ImuSensor() = default;
};

#endif