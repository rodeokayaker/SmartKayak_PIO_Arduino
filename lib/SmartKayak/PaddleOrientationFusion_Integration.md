# Интеграция системы адаптивной ориентации весла

## Описание решения

Система `PaddleOrientationFusion` решает проблему точного определения относительной ориентации весла относительно каяка, комбинируя несколько источников данных:

### 1. **DMP кватернионы (гироскоп + акселерометр)** - основной источник (95-98%)
   - Высокая частота обновления
   - Хорошая кратковременная точность
   - Не подвержен магнитным помехам
   - **Проблема**: дрифт по yaw со временем

### 2. **Магнитометр** - коррекция дрифта (2-5% при хорошем качестве)
   - Абсолютная референция по направлению
   - **Проблема**: подвержен помехам от металла, электроники
   - **Решение**: используется только когда качество отличное/хорошее

### 3. **Паттерны гребли** - валидация и предсказание (0-20%)
   - Гребля циклична и предсказуема
   - Система обучается паттернам за 5-10 гребков
   - **Применение**: 
     - Валидация текущей ориентации
     - Коррекция при плохих данных магнитометра
     - Предсказание в переходных моментах

## Алгоритм работы

```
┌─────────────────────────────────────────────────────────────┐
│                   ВХОДНЫЕ ДАННЫЕ                            │
│  - DMP кватернионы каяка и весла (100 Гц)                  │
│  - IMU данные (акселерометр, гироскоп, магнитометр)        │
│  - Сила на лопасти                                          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 1: Базовая относительная ориентация             │
│  - Используем DMP кватернионы                               │
│  - Проецируем каяк на горизонталь (убираем pitch/roll)     │
│  - Вычисляем: q_rel = q_kayak_horiz⁻¹ * q_paddle           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 2: Оценка качества магнитометра                 │
│  ✓ EXCELLENT: дисперсия < 30% порога                       │
│  ✓ GOOD:      дисперсия < 70% порога                       │
│  ✗ POOR:      дисперсия < 100% порога                      │
│  ✗ INVALID:   дисперсия > порога или аномалии              │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 3: Определение фазы гребка                      │
│  - CATCH (захват): tilt < -10°, force < 400                │
│  - DRIVE (гребок): tilt < 0°,  force > 400                 │
│  - RELEASE (выход): tilt > 10°, force < 400                │
│  - RECOVERY (возврат): force < 400                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 4: Обучение/обновление паттернов                │
│  - При каждом CATCH обновляем паттерн                       │
│  - Диапазоны углов с экспоненциальным сглаживанием         │
│  - После 5 гребков паттерн готов к использованию           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 5: Коррекция дрифта                             │
│  - Оценка скорости дрифта в фазе RECOVERY                  │
│  - Малая коррекция по yaw: q_corr = q_drift * q_base       │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 6: Магнитная коррекция (условно)               │
│  ЕСЛИ качество = EXCELLENT или GOOD:                        │
│    - Вычисляем yaw из магнитометра (tilt compensated)      │
│    - Находим ошибку: error = yaw_mag - yaw_dmp             │
│    - Коррекция: q_mag = q_correction * q_base              │
│  ИНАЧЕ:                                                     │
│    - Пропускаем коррекцию                                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 7: Коррекция по паттерну (если обучен)         │
│  ЕСЛИ углы выходят за границы паттерна:                     │
│    - Мягкая коррекция к границам                            │
│    - Вес: 10-20% в зависимости от качества mag             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         ШАГ 8: Комплементарный фильтр (SLERP)              │
│  Адаптивные веса:                                           │
│  - DMP: 95-98%                                              │
│  - MAG: 0-5% (зависит от качества)                         │
│  - PATTERN: 0-20% (больше при плохом mag)                  │
│                                                             │
│  q_final = SLERP(q_dmp, q_mag, w_mag) ⊕                    │
│            SLERP(result, q_pattern, w_pattern)             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              ВЫХОД: Точная относительная ориентация         │
└─────────────────────────────────────────────────────────────┘
```

## Интеграция в SmartKayak

### Шаг 1: Добавить в SmartKayak.h

```cpp
#include "PaddleOrientationFusion.h"

class SmartKayak {
    // ... существующие поля ...
    
    PaddleOrientationFusion orientationFusion;  // Новая система
    
public:
    // ... существующие методы ...
};
```

### Шаг 2: Инициализация в конструкторе

```cpp
SmartKayak::SmartKayak():
    // ... существующая инициализация ...
{
    // Настройка весов фильтра
    orientationFusion.setFilterWeights(
        0.97f,  // DMP weight
        0.03f,  // Magnetometer weight
        0.0f    // Pattern weight (will grow with learning)
    );
    
    // Настройка порогов магнитометра
    orientationFusion.setMagnetometerThresholds(
        500.0f,  // Variance threshold
        100.0f   // Deviation threshold
    );
}
```

### Шаг 3: Замена в методе update()

**Было:**
```cpp
SP_Math::Quaternion currentPaddleQ(paddleOrientation.q0,paddleOrientation.q1,
                                    paddleOrientation.q2,paddleOrientation.q3);
SP_Math::Quaternion paddleRelativeQuat = getRelativeOrientation(currentPaddleQ,paddle);
```

**Стало:**
```cpp
// Получаем IMU данные для оценки качества
IMUData kayakIMU;
imu->getData(kayakIMU);
IMUData paddleIMU = paddle->getIMUData();

// Получаем ориентацию каяка
OrientationData kayakOrientation;
kayakOrientation.q0 = kayakOrientationQuat[0];
kayakOrientation.q1 = kayakOrientationQuat[1];
kayakOrientation.q2 = kayakOrientationQuat[2];
kayakOrientation.q3 = kayakOrientationQuat[3];

// Используем новую систему
SP_Math::Quaternion paddleRelativeQuat = orientationFusion.update(
    kayakIMU,
    paddleIMU,
    kayakOrientation,
    paddleOrientation,
    bladeForce  // Передаем текущую силу для определения фазы
);
```

## Преимущества решения

### 1. **Устойчивость к магнитным помехам**
   - Магнитометр используется только при хорошем качестве
   - Автоматическое обнаружение аномалий и помех
   - При помехах система полагается на DMP + паттерны

### 2. **Компенсация дрифта**
   - Отслеживание дрифта в фазе возврата весла
   - Малая непрерывная коррекция
   - Магнитная коррекция при хороших условиях

### 3. **Использование цикличности гребли**
   - Автоматическое обучение паттернам
   - Валидация текущей ориентации
   - Предсказание при неопределенных данных

### 4. **Адаптивность**
   - Веса фильтра меняются в зависимости от качества данных
   - Больший вес паттернам при плохом магнитометре
   - Больший вес магнитометру при отличном качестве

## Мониторинг и отладка

### Добавление в логирование

```cpp
void SmartKayak::logCall(ILogInterface* logger, LogMode logMode, ...) {
    // ... существующий код ...
    
    // Добавить статистику fusion
    int strokes;
    bool learned;
    float driftRate;
    orientationFusion.getStats(strokes, learned, driftRate);
    
    MagnetometerQuality magQuality = orientationFusion.getCurrentMagQuality(
        kayakIMU, paddleIMU
    );
    
    logger->printf("Strokes: %d, Learned: %d, Drift: %.3f, MagQ: %d, Phase: %d\n",
        strokes, learned, driftRate, (int)magQuality, 
        (int)orientationFusion.getStrokePhase());
}
```

### Визуализация в Display

```cpp
displayData.strokePhase = (int)orientationFusion.getStrokePhase();
displayData.magQuality = (int)orientationFusion.getCurrentMagQuality(...);
displayData.patternsLearned = orientationFusion.isLearned();
```

## Настройка параметров

### Для спокойной воды (меньше помех)
```cpp
orientationFusion.setFilterWeights(0.95f, 0.05f, 0.0f);  // Больше доверия магнитометру
orientationFusion.setMagnetometerThresholds(800.0f, 150.0f);  // Более мягкие пороги
```

### Для бурной воды или помех
```cpp
orientationFusion.setFilterWeights(0.98f, 0.02f, 0.0f);  // Меньше доверия магнитометру
orientationFusion.setMagnetometerThresholds(300.0f, 50.0f);   // Более строгие пороги
```

### Сброс паттернов при смене стиля гребли
```cpp
if (userChangedPaddlingStyle) {
    orientationFusion.resetPatterns();
}
```

## Результат

✅ **Точность**: высокая точность даже при магнитных помехах  
✅ **Надежность**: автоматическая адаптация к условиям  
✅ **Стабильность**: минимальный дрифт благодаря комбинированной коррекции  
✅ **Предсказуемость**: использование паттернов для валидации  
